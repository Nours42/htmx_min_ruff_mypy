((e, t) => {
	if (typeof define === "function" && define.amd) {
		define([], t);
	} else {
		e.htmx = t();
	}
})(typeof self !== "undefined" ? self : this, () =>
	(() => {
		const D = {
			onLoad: t,
			process: nt,
			on: N,
			off: I,
			trigger: ft,
			ajax: Jt,
			find: w,
			findAll: S,
			closest: L,
			values: (e, t) => {
				const r = Tt(e, t || "post");
				return r.values;
			},
			remove: E,
			addClass: C,
			removeClass: q,
			toggleClass: R,
			takeClass: O,
			defineExtension: er,
			removeExtension: tr,
			logAll: b,
			logger: null,
			config: {
				historyEnabled: true,
				historyCacheSize: 10,
				refreshOnHistoryMiss: false,
				defaultSwapStyle: "innerHTML",
				defaultSwapDelay: 0,
				defaultSettleDelay: 20,
				includeIndicatorStyles: true,
				indicatorClass: "htmx-indicator",
				requestClass: "htmx-request",
				settlingClass: "htmx-settling",
				swappingClass: "htmx-swapping",
				allowEval: true,
				attributesToSettle: ["class", "style", "width", "height"],
				withCredentials: false,
				timeout: 0,
				wsReconnectDelay: "full-jitter",
				disableSelector: "[hx-disable], [data-hx-disable]",
				useTemplateFragments: false,
				scrollBehavior: "smooth",
			},
			parseInterval: h,
			_: e,
			createEventSource: (e) => new EventSource(e, { withCredentials: true }),
			createWebSocket: (e) => new WebSocket(e, []),
			version: "1.5.0",
		};
		const r = ["get", "post", "put", "delete", "patch"];
		const n = r.map((e) => `[hx-${e}], [data-hx-${e}]`).join(", ");
		function h(e) {
			if (e === undefined) {
				return undefined;
			}
			if (e.slice(-2) === "ms") {
				return parseFloat(e.slice(0, -2)) || undefined;
			}
			if (e.slice(-1) === "s") {
				return parseFloat(e.slice(0, -1)) * 1e3 || undefined;
			}
			return parseFloat(e) || undefined;
		}
		function c(e, t) {
			return e.getAttribute?.(t);
		}
		function s(e, t) {
			return (
				e.hasAttribute && (e.hasAttribute(t) || e.hasAttribute(`data-${t}`))
			);
		}
		function F(e, t) {
			return c(e, t) || c(e, `data-${t}`);
		}
		function l(e) {
			return e.parentElement;
		}
		function X() {
			return document;
		}
		function d(e, t) {
			if (t(e)) {
				return e;
			}
			if (l(e)) {
				return d(l(e), t);
			}
			return null;
		}
		function P(e, t) {
			let r = null;
			d(e, (e) => {
				r = F(e, t);
			});
			return r;
		}
		function v(e, t) {
			const r =
				e.matches ||
				e.matchesSelector ||
				e.msMatchesSelector ||
				e.mozMatchesSelector ||
				e.webkitMatchesSelector ||
				e.oMatchesSelector;
			return r?.call(e, t);
		}
		function i(e) {
			const t = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
			const r = t.exec(e);
			if (r) {
				return r[1].toLowerCase();
			}
			return "";
		}
		function o(e, t) {
			const r = new DOMParser();
			const n = r.parseFromString(e, "text/html");
			let i = n.body;
			let count = t;
			while (count > 0) {
				count--;
				i = i.firstChild;
			}
			if (i === null) {
				i = X().createDocumentFragment();
			}
			return i;
		}

		function u(e) {
			let t;
			if (D.config.useTemplateFragments) {
				t = o(`<body><template>${e}</template></body>`, 0);
				return t.querySelector("template").content;
			}
			const r = i(e);
			switch (r) {
				case "thead":
				case "tbody":
				case "tfoot":
				case "colgroup":
				case "caption":
					return o(`<table>${e}</table>`, 1);
				case "col":
					return o(`<table>${e}</table>`, 1);
				case "tr":
					return o(`<table><colgroup>${e}</colgroup></table>`, 2);
				case "td":
				case "th":
					return o(`<table><tbody><tr>${e}</tr></tbody></table>`, 3);
				case "script":
					return o(`<div>${e}</div>`, 1);
				default:
					return o(e, 0);
			}
		}
		function U(e) {
			if (e) {
				e();
			}
		}
		function a(e, t) {
			return Object.prototype.toString.call(e) === `[object ${t}]`;
		}
		function f(e) {
			return a(e, "Function");
		}
		function g(e) {
			return a(e, "Object");
		}
		function j(e) {
			const t = "htmx-internal-data";
			let r = e[t];
			if (!r) {
				r = e[t] = {};
			}
			return r;
		}
		function p(e) {
			const t = [];
			let r;
			if (e) {
				for (r = 0; r < e.length; r++) {
					t.push(e[r]);
				}
			}
			return t;
		}
		function B(e, t) {
			let r;
			if (e) {
				for (r = 0; r < e.length; r++) {
					t(e[r]);
				}
			}
		}
		function m(e) {
			const t = e.getBoundingClientRect();
			const r = t.top;
			const n = t.bottom;
			return r < window.innerHeight && n >= 0;
		}
		function z(e) {
			return X().body.contains(e);
		}
		function y(e) {
			return e.trim().split(/\s+/);
		}
		function V(e, t) {
			for (const r in t) {
				if (t.hasOwn(r)) {
					e[r] = t[r];
				}
			}
			return e;
		}
		function x(e) {
			try {
				return JSON.parse(e);
			} catch (e) {
				lt(e);
				return null;
			}
		}
		function e(e) {
			return jt(X().body, () => eval(e));
		}
		function t(t) {
			const e = D.on("htmx:load", (e) => {
				t(e.detail.elt);
			});
			return e;
		}
		function b() {
			D.logger = (e, t, r) => {
				if (console) {
					console.log(t, e, r);
				}
			};
		}
		function w(e, t) {
			if (t) {
				return e.querySelector(t);
			}
			return w(X(), e);
		}
		function S(e, t) {
			if (t) {
				return e.querySelectorAll(t);
			}
			return S(X(), e);
		}
		function E(element, t) {
			const modifiedElement = H(element);
			if (t) {
				setTimeout(() => {
					E(modifiedElement);
				}, t);
			}
			modifiedElement.parentElement.removeChild(modifiedElement);
		}

		function C(element, t, r) {
			const modifiedElement = H(element);
			if (r) {
				setTimeout(() => {
					C(modifiedElement, t);
				}, r);
			}
			modifiedElement.classList.add(t);
		}

		function q(element, t, r) {
			const modifiedElement = H(element);
			if (r) {
				setTimeout(() => {
					q(modifiedElement, t);
				}, r);
			}
			modifiedElement.classList.remove(t);
		}

		function R(element, t) {
			const modifiedElement = H(element);
			modifiedElement.classList.toggle(t);
		}

		function O(element, t) {
			const modifiedElement = H(element);
			B(modifiedElement.parentElement.children, (child) => {
				q(child, t);
			});
			C(modifiedElement, t);
		}

		function L(element, t) {
			let modifiedElement = H(element);
			if (modifiedElement.closest) {
				return modifiedElement.closest(t);
			}
			do {
				if (modifiedElement === null || v(modifiedElement, t)) {
					return modifiedElement;
				}
				modifiedElement = modifiedElement && l(modifiedElement);
			} while (modifiedElement);
		}

		function T(e, t) {
			if (t.indexOf("closest ") === 0) {
				return [L(e, t.substr(8))];
			}
			if (t.indexOf("find ") === 0) {
				return [w(e, t.substr(5))];
			}
			if (t === "document") {
				return [document];
			}
			return X().querySelectorAll(t);
		}
		function A(e, t) {
			return T(e, t)[0];
		}
		function H(e) {
			if (a(e, "String")) {
				return w(e);
			}
			return e;
		}
		function k(e, t, r) {
			if (f(t)) {
				return { target: X().body, event: e, listener: t };
			}
			return { target: H(e), event: t, listener: r };
		}
		function N(t, r, n) {
			let e;
			nr(() => {
				e = k(t, r, n);
				e.target.addEventListener(e.event, e.listener);
			});
			e = f(r);
			return e ? r : n;
		}
		function I(t, r, n) {
			let e;
			nr(() => {
				e = k(t, r, n);
				e.target.removeEventListener(e.event, e.listener);
			});
			return f(r) ? r : n;
		}
		function _(e) {
			const t = d(e, (e) => F(e, "hx-target") !== null);
			let r;
			if (t) {
				r = F(t, "hx-target");
				if (r === "this") {
					return t;
				}
				return A(e, r);
			}
			const n = j(e);
			if (n.boosted) {
				return X().body;
			}
			return e;
		}
		function M(e) {
			const t = D.config.attributesToSettle;
			let r;
			for (r = 0; r < t.length; r++) {
				if (e === t[r]) {
					return true;
				}
			}
			return false;
		}
		function W(t, r) {
			B(t.attributes, (e) => {
				if (!r.hasAttribute(e.name) && M(e.name)) {
					t.removeAttribute(e.name);
				}
			});
			B(r.attributes, (e) => {
				if (M(e.name)) {
					t.setAttribute(e.name, e.value);
				}
			});
		}
		function $(e, t) {
			const r = rr(t);
			let n;
			let i;
			for (n = 0; n < r.length; n++) {
				i = r[n];
				try {
					if (i.isInlineSwap(e)) {
						return true;
					}
				} catch (e) {
					lt(e);
				}
			}
			return e === "outerHTML";
		}
		function J(e, t, r) {
			let n = `#${t.id}`;
			let i = "outerHTML";
			let a;
			if (e === "true") {
			} else if (e.indexOf(":") > 0) {
				i = e.substr(0, e.indexOf(":"));
				n = e.substr(e.indexOf(":") + 1, e.length);
			} else {
				i = e;
			}
			const o = X().querySelector(n);
			if (o) {
				a = X().createDocumentFragment();
				a.appendChild(t);
				if (!$(i, o)) {
					a = t;
				}
				le(i, o, o, a, r);
			} else {
				t.parentNode.removeChild(t);
				at(X().body, "htmx:oobErrorNoTarget", { content: t });
			}
			return e;
		}
		function Z(e, r) {
			B(S(e, "[hx-swap-oob], [data-hx-swap-oob]"), (e) => {
				const t = F(e, "hx-swap-oob");
				if (t != null) {
					J(t, e, r);
				}
			});
		}
		function G(e) {
			B(S(e, "[hx-preserve], [data-hx-preserve]"), (e) => {
				const t = F(e, "id");
				const r = X().getElementById(t);
				if (r != null) {
					e.parentNode.replaceChild(r, e);
				}
			});
		}
		function K(n, e, i) {
			let t;
			let r;
			B(e.querySelectorAll("[id]"), (e) => {
				if (e.id && e.id.length > 0) {
					t = n.querySelector(`${e.tagName}[id='${e.id}']`);
					if (t && t !== n) {
						r = e.cloneNode();
						W(e, t);
						i.tasks.push(() => {
							W(e, r);
						});
					}
				}
			});
		}
		function Y(e) {
			return () => {
				nt(e);
				Ye(e);
				Q(e);
				ft(e, "htmx:load");
			};
		}
		function Q(e) {
			const t = "[autofocus]";
			const r = v(e, t) ? e : e.querySelector(t);
			if (r != null) {
				r.focus();
			}
		}
		function ee(e, t, r, n) {
			K(e, r, n);
			let i;
			while (r.childNodes.length > 0) {
				i = r.firstChild;
				e.insertBefore(i, t);
				if (i.nodeType !== Node.TEXT_NODE && i.nodeType !== Node.COMMENT_NODE) {
					n.tasks.push(Y(i));
				}
			}
		}
		function te(t) {
			const e = j(t);
			if (e.webSocket) {
				e.webSocket.close();
			}
			if (e.sseEventSource) {
				e.sseEventSource.close();
			}
			if (e.listenerInfos) {
				B(e.listenerInfos, (e) => {
					if (t !== e.on) {
						e.on.removeEventListener(e.trigger, e.listener);
					}
				});
			}
			if (t.children) {
				B(t.children, (e) => {
					te(e);
				});
			}
		}
		function re(e, t, r) {
			let n;
			let i;
			if (e.tagName === "BODY") {
				return se(e, t, r);
			}
			n = e.previousSibling;
			ee(l(e), e, t, r);
			if (n === null) {
				i = l(e).firstChild;
			} else {
				i = n.nextSibling;
			}
			j(e).replacedWith = i;
			r.elts = [];
			while (i && i !== e) {
				if (i.nodeType === Node.ELEMENT_NODE) {
					r.elts.push(i);
				}
				i = i.nextElementSibling;
			}
			te(e);
			l(e).removeChild(e);
		}
		function ne(e, t, r) {
			return ee(e, e.firstChild, t, r);
		}
		function ie(e, t, r) {
			return ee(l(e), e, t, r);
		}
		function oe(e, t, r) {
			return ee(e, null, t, r);
		}
		function ae(e, t, r) {
			return ee(l(e), e.nextSibling, t, r);
		}
		function se(e, t, r) {
			const n = e.firstChild;
			ee(e, n, t, r);
			if (n) {
				while (n.nextSibling) {
					te(n.nextSibling);
					e.removeChild(n.nextSibling);
				}
				te(n);
				e.removeChild(n);
			}
		}
		function ue(e, t) {
			const r = P(e, "hx-select");
			let n;
			let modifiedElement = t;
			if (r) {
				n = X().createDocumentFragment();
				B(modifiedElement.querySelectorAll(r), (element) => {
					n.appendChild(element);
				});
				modifiedElement = n;
			}
			return modifiedElement;
		}

		function le(e, t, r, n, i) {
			let o;
			let a;
			let s;
			let u;
			let l;
			let f;
			switch (e) {
				case "none":
					return;
				case "outerHTML":
					re(r, n, i);
					return;
				case "afterbegin":
					ne(r, n, i);
					return;
				case "beforebegin":
					ie(r, n, i);
					return;
				case "beforeend":
					oe(r, n, i);
					return;
				case "afterend":
					ae(r, n, i);
					return;
				default:
					o = rr(t);
					for (a = 0; a < o.length; a++) {
						s = o[a];
						try {
							u = s.handleSwap(e, r, n, i);
							if (u) {
								if (typeof u.length !== "undefined") {
									for (l = 0; l < u.length; l++) {
										f = u[l];
										if (
											f.nodeType !== Node.TEXT_NODE &&
											f.nodeType !== Node.COMMENT_NODE
										) {
											i.tasks.push(Y(f));
										}
									}
								}
								return;
							}
						} catch (e) {
							lt(e);
						}
					}
					se(r, n, i);
			}
		}
		const fe = /<title>([\s\S]+?)<\/title>/im;
		function ce(e) {
			let t;
			if (
				e.indexOf("<title>") > -1 &&
				(e.indexOf("<svg>") === -1 || e.indexOf("<title>") < e.indexOf("<svg>"))
			) {
				t = fe.exec(e);
				if (t) {
					return t[1];
				}
			}
		}
		function he(e, t, r, n, i) {
			const o = ce(n);
			let a;
			if (o) {
				a = w("title");
				if (a) {
					a.innerHTML = o;
				}
				window.document.title = o;
			}
			let s = u(n);
			if (s) {
				Z(s, i);
				s = ue(r, s);
				G(s);
				return le(e, r, t, s, i);
			}
		}
		function de(e, t, r) {
			const n = e.getResponseHeader(t);
			let a;
			let i;
			let o;
			if (n.indexOf("{") === 0) {
				i = x(n);
				for (o in i) {
					if (i.hasOwn(o)) {
						a = i[o];
						if (!g(a)) {
							a = { value: a };
						}
						ft(r, o, a);
					}
				}
			}
			ft(r, n, []);
		}
		const ve = /\s/;
		const ge = /[\s,]/;
		const pe = /[_$a-zA-Z]/;
		const me = /[_$a-zA-Z0-9]/;
		const ye = ['"', "'", "/"];
		const xe = /[^\s]/;
		function be(e) {
			const t = [];
			let r = 0;
			let n;
			let i;
			let o;
			while (r < e.length) {
				if (pe.exec(e.charAt(r))) {
					n = r;
					while (me.exec(e.charAt(r + 1))) {
						r++;
					}
					t.push(e.substr(n, r - n + 1));
				} else if (ye.indexOf(e.charAt(r)) !== -1) {
					i = e.charAt(r);
					n = r;
					r++;
					while (r < e.length && e.charAt(r) !== i) {
						if (e.charAt(r) === "\\") {
							r++;
						}
						r++;
					}
					t.push(e.substr(n, r - n + 1));
				} else {
					o = e.charAt(r);
					t.push(o);
				}
				r++;
			}
			return t;
		}
		function we(e, t, r) {
			return (
				pe.exec(e.charAt(0)) &&
				e !== "true" &&
				e !== "false" &&
				e !== "this" &&
				e !== r &&
				t !== "."
			);
		}
		function Se(e, t, r) {
			let n;
			let i;
			let o;
			let a;
			let s;
			if (t[0] === "[") {
				t.shift();
				n = 1;
				i = ` return (function(${r}){ return (`;
				o = null;
				while (t.length > 0) {
					a = t[0];
					if (a === "]") {
						n--;
						if (n === 0) {
							if (o === null) {
								i = `${i}true`;
							}
							t.shift();
							i += ")})";
							try {
								s = jt(
									e,
									() => Function(i)(),
									() => true,
								);
								s.source = i;
								return s;
							} catch (e) {
								at(X().body, "htmx:syntax:error", { error: e, source: i });
								return null;
							}
						}
					} else if (a === "[") {
						n++;
					}
					if (we(a, o, r)) {
						i += `((${r}.${a}) ? (${r}.${a}) : (window.${a}))`;
					} else {
						i = i + a;
					}
					o = t.shift();
				}
			}
		}
		function Ee(e, t) {
			let r = "";
			while (e.length > 0 && !e[0].match(t)) {
				r += e.shift();
			}
			return r;
		}
		const Ce = "input, textarea, select";
		function qe(e) {
			const t = F(e, "hx-trigger");
			const r = [];
			let n;
			let i;
			let o;
			let a;
			let s;
			let u;
			let l;
			if (t) {
				n = be(t);
				do {
					Ee(n, xe);
					i = n.length;
					o = Ee(n, /[,\[\s]/);
					if (o !== "") {
						if (o === "every") {
							a = { trigger: "every" };
							Ee(n, xe);
							a.pollInterval = h(Ee(n, /[,\[\s]/));
							Ee(n, xe);
							s = Se(e, n, "event");
							if (s) {
								a.eventFilter = s;
							}
							r.push(a);
						} else if (o.indexOf("sse:") === 0) {
							r.push({ trigger: "sse", sseEvent: o.substr(4) });
						} else {
							u = { trigger: o };
							s = Se(e, n, "event");
							if (s) {
								u.eventFilter = s;
							}
							while (n.length > 0 && n[0] !== ",") {
								Ee(n, xe);
								l = n.shift();
								if (l === "changed") {
									u.changed = true;
								} else if (l === "once") {
									u.once = true;
								} else if (l === "consume") {
									u.consume = true;
								} else if (l === "delay" && n[0] === ":") {
									n.shift();
									u.delay = h(Ee(n, ge));
								} else if (l === "from" && n[0] === ":") {
									n.shift();
									u.from = Ee(n, ge);
								} else if (l === "target" && n[0] === ":") {
									n.shift();
									u.target = Ee(n, ge);
								} else if (l === "throttle" && n[0] === ":") {
									n.shift();
									u.throttle = h(Ee(n, ge));
								} else if (l === "queue" && n[0] === ":") {
									n.shift();
									u.queue = Ee(n, ge);
								} else if (
									(l === "root" || l === "threshold") &&
									n[0] === ":"
								) {
									n.shift();
									u[l] = Ee(n, ge);
								} else {
									at(e, "htmx:syntax:error", { token: n.shift() });
								}
							}
							r.push(u);
						}
					}
					if (n.length === i) {
						at(e, "htmx:syntax:error", { token: n.shift() });
					}
					Ee(n, xe);
				} while (n[0] === "," && n.shift());
			}
			if (r.length > 0) {
				return r;
			}
			if (v(e, "form")) {
				return [{ trigger: "submit" }];
			}
			if (v(e, Ce)) {
				return [{ trigger: "change" }];
			}
			return [{ trigger: "click" }];
		}
		function Re(e) {
			j(e).cancelled = true;
		}
		function Oe(e, t, r, n) {
			const i = j(e);
			i.timeout = setTimeout(() => {
				if (z(e) && i.cancelled !== true) {
					if (!ke(n, ot("hx:poll:trigger", { triggerSpec: n }))) {
						Gt(t, r, e);
					}
					Oe(e, t, F(e, `hx-${t}`), n);
				}
			}, n.pollInterval);
		}
		function Le(e) {
			return (
				location.hostname === e.hostname &&
				c(e, "href") &&
				c(e, "href").indexOf("#") !== 0
			);
		}
		function Te(t, r, e) {
			let n;
			let i;
			let o;
			if ((t.tagName === "A" && Le(t)) || t.tagName === "FORM") {
				r.boosted = true;
				if (t.tagName === "A") {
					n = "get";
					i = c(t, "href");
					r.pushURL = true;
				} else {
					o = c(t, "method");
					n = o ? o.toLowerCase() : "get";
					if (n === "get") {
						r.pushURL = true;
					}
					i = c(t, "action");
				}
				for (const element of e) {
					Ne(t, n, i, r, element, true);
				}
			}
		}

		function Ae(e) {
			return (
				e.tagName === "FORM" ||
				(v(e, 'input[type="submit"], button') && L(e, "form") !== null) ||
				(e.tagName === "A" &&
					e.href &&
					(e.getAttribute("href") === "#" ||
						e.getAttribute("href").indexOf("#") !== 0))
			);
		}
		function He(e, t) {
			return (
				j(e).boosted &&
				e.tagName === "A" &&
				t.type === "click" &&
				(t.ctrlKey || t.metaKey)
			);
		}
		function ke(e, t) {
			const r = e.eventFilter;
			if (r) {
				try {
					return r(t) !== true;
				} catch (e) {
					at(X().body, "htmx:eventFilter:error", {
						error: e,
						source: r.source,
					});
					return true;
				}
			}
			return false;
		}
		function Ne(o, a, s, e, u, l) {
			let t;
			let i;
			let r;
			if (u.from) {
				t = T(o, u.from);
			} else {
				t = [o];
			}
			B(t, (n) => {
				i = (e) => {
					if (!z(o)) {
						n.removeEventListener(u.trigger, i);
						return;
					}
					if (He(o, e)) {
						return;
					}
					if (l || Ae(o)) {
						e.preventDefault();
					}
					if (ke(u, e)) {
						return;
					}
					t = j(e);
					t.triggerSpec = u;
					if (t.handledFor === null) {
						t.handledFor = [];
					}
					r = j(o);
					if (t.handledFor.indexOf(o) < 0) {
						t.handledFor.push(o);
						if (u.consume) {
							e.stopPropagation();
						}
						if (u.target && e.target) {
							if (!v(e.target, u.target)) {
								return;
							}
						}
						if (u.once) {
							if (r.triggeredOnce) {
								return;
							}
							r.triggeredOnce = true;
						}
						if (u.changed) {
							if (r.lastValue === o.value) {
								return;
							}
							r.lastValue = o.value;
						}
						if (r.delayed) {
							clearTimeout(r.delayed);
						}
						if (r.throttle) {
							return;
						}
						if (u.throttle) {
							if (!r.throttle) {
								Gt(a, s, o, e);
								r.throttle = setTimeout(() => {
									r.throttle = null;
								}, u.throttle);
							}
						} else if (u.delay) {
							r.delayed = setTimeout(() => {
								Gt(a, s, o, e);
							}, u.delay);
						} else {
							Gt(a, s, o, e);
						}
					}
				};
				if (e.listenerInfos === null) {
					e.listenerInfos = [];
				}
				e.listenerInfos.push({ trigger: u.trigger, listener: i, on: n });
				n.addEventListener(u.trigger, i);
			});
		}
		let Ie = false;
		let Me = null;
		function De() {
			if (!Me) {
				Me = () => {
					Ie = true;
				};
				window.addEventListener("scroll", Me);
				setInterval(() => {
					if (Ie) {
						Ie = false;
						B(
							X().querySelectorAll(
								"[hx-trigger='revealed'],[data-hx-trigger='revealed']",
							),
							(e) => {
								Fe(e);
							},
						);
					}
				}, 200);
			}
		}
		function Fe(e) {
			const t = j(e);
			if (!t.revealed && m(e)) {
				t.revealed = true;
				if (t.initialized) {
					Gt(t.verb, t.path, e);
				} else {
					e.addEventListener(
						"htmx:afterProcessNode",
						() => {
							Gt(t.verb, t.path, e);
						},
						{ once: true },
					);
				}
			}
		}
		function Xe(e, t, r) {
			const n = y(r);
			let i;
			let o;
			for (i = 0; i < n.length; i++) {
				o = n[i].split(/:(.+)/);
				if (o[0] === "connect") {
					Pe(e, o[1], 0);
				}
				if (o[0] === "send") {
					je(e);
				}
			}
		}
		function Pe(s, r, n) {
			let e;
			let modifiedUrl = r;
			let retryCount = n;

			if (!z(s)) {
				return;
			}

			if (modifiedUrl.indexOf("/") === 0) {
				e = location.hostname + (location.port ? `:${location.port}` : "");
				if (location.protocol === "https:") {
					modifiedUrl = `wss://${e}${modifiedUrl}`;
				} else if (location.protocol === "http:") {
					modifiedUrl = `ws://${e}${modifiedUrl}`;
				}
			}

			let t = D.createWebSocket(modifiedUrl);

			t.onerror = (e) => {
				at(s, "htmx:wsError", { error: e, socket: t });
				Ue(s);
			};

			t.onclose = (e) => {
				if ([1006, 1012, 1013].indexOf(e.code) >= 0) {
					t = Be(retryCount);
					setTimeout(() => {
						Pe(s, modifiedUrl, retryCount + 1);
					}, t);
				}
			};

			t.onopen = (e) => {
				retryCount = 0;
			};

			j(s).webSocket = t;

			let o;
			let a;

			t.addEventListener("message", (e) => {
				if (Ue(s)) {
					return;
				}
				t = e.data;
				ut(s, (e) => {
					t = e.transformResponse(t, null, s);
				});
				const response = Xt(s);
				const parsedData = u(t);
				const childrenArray = p(parsedData.children);
				for (o = 0; o < childrenArray.length; o++) {
					a = childrenArray[o];
					J(F(a, "hx-swap-oob") || "true", a, response);
				}
				yt(response.tasks);
			});
		}

		function Ue(e) {
			if (!z(e)) {
				j(e).webSocket.close();
				return true;
			}
		}
		function je(l) {
			const f = d(l, (e) => j(e).webSocket != null);
			if (f) {
				l.addEventListener(qe(l)[0].trigger, (e) => {
					const t = j(f).webSocket;
					const r = Nt(l, f);
					const n = Tt(l, "post");
					const i = n.errors;
					const o = n.values;
					const a = Vt(l);
					const s = V(o, a);
					const u = It(s, l);
					u.HEADERS = r;
					if (i && i.length > 0) {
						ft(l, "htmx:validation:halted", i);
						return;
					}
					t.send(JSON.stringify(u));
					if (Ae(l)) {
						e.preventDefault();
					}
				});
			} else {
				at(l, "htmx:noWebSocketSourceError");
			}
		}
		function Be(e) {
			const t = D.config.wsReconnectDelay;
			let r;
			let n;
			if (typeof t === "function") {
				return t(e);
			}
			if (t === "full-jitter") {
				r = Math.min(e, 6);
				n = 1e3 * 2 ** r;
				return n * Math.random();
			}
			lt(
				'htmx.config.wsReconnectDelay must either be a function or the string "full-jitter"',
			);
		}
		function ze(e, t, r) {
			const n = y(r);
			let i;
			let o;
			for (i = 0; i < n.length; i++) {
				o = n[i].split(/:(.+)/);
				if (o[0] === "connect") {
					Ve(e, o[1]);
				}
				if (o[0] === "swap") {
					_e(e, o[1]);
				}
			}
		}
		function Ve(t, e) {
			const r = D.createEventSource(e);
			r.onerror = (e) => {
				at(t, "htmx:sseError", { error: e, source: r });
				$e(t);
			};
			j(t).sseEventSource = r;
		}
		function _e(o, a) {
			const s = d(o, Je);
			let u;
			let l;
			if (s) {
				u = j(s).sseEventSource;
				l = (e) => {
					if ($e(s)) {
						u.removeEventListener(a, l);
						return;
					}
					let t = e.data;
					ut(o, (e) => {
						t = e.transformResponse(t, null, o);
					});
					const r = Dt(o);
					const n = _(o);
					const i = Xt(o);
					he(r.swapStyle, o, n, t, i);
					yt(i.tasks);
					ft(o, "htmx:sseMessage", e);
				};
				j(o).sseListener = l;
				u.addEventListener(a, l);
			} else {
				at(o, "htmx:noSSESourceError");
			}
		}
		function We(e, t, r, n) {
			const i = d(e, Je);
			let o;
			let a;
			if (i) {
				o = j(i).sseEventSource;
				a = () => {
					if (!$e(i)) {
						if (z(e)) {
							Gt(t, r, e);
						} else {
							o.removeEventListener(n, a);
						}
					}
				};
				j(e).sseListener = a;
				o.addEventListener(n, a);
			}
			at(e, "htmx:noSSESourceError");
		}
		function $e(e) {
			if (!z(e)) {
				j(e).sseEventSource.close();
				return true;
			}
		}
		function Je(e) {
			return j(e).sseEventSource != null;
		}
		function Ze(e, t, r, n, i) {
			const o = () => {
				if (!n.loaded) {
					n.loaded = true;
					Gt(t, r, e);
				}
			};
			if (i) {
				setTimeout(o, i);
			}
			o();
		}
		function Ge(o, a, e) {
			let t = false;
			let i;
			let r;
			B(r, (n) => {
				if (s(o, `hx-${n}`)) {
					i = F(o, `hx-${n}`);
					t = true;
					a.path = i;
					a.verb = n;
					for (const event of e) {
						if (event.sseEvent) {
							We(o, n, i, event.sseEvent);
						} else if (event.trigger === "revealed") {
							De();
							Fe(o);
						} else if (event.trigger === "intersect") {
							t = {};
							if (event.root) {
								t.root = A(event.root);
							}
							if (event.threshold) {
								t.threshold = parseFloat(event.threshold);
							}
							r = new IntersectionObserver((entries) => {
								for (const entry of entries) {
									if (entry.isIntersecting) {
										ft(o, "intersect");
										break;
									}
								}
							}, t);
							r.observe(o);
							Ne(o, n, i, a, event);
						} else if (event.trigger === "load") {
							Ze(o, n, i, a, event.delay);
						} else if (event.pollInterval) {
							a.polling = true;
							Oe(o, n, i, event);
						} else {
							Ne(o, n, i, a, event);
						}
					}
				}
			});
			return t;
		}
		function Ke(e) {
			if (e.type === "text/javascript" || e.type === "") {
				try {
					jt(e, () => {
						window.eval(e.innerText);
					});
				} catch (e) {
					lt(e);
				}
			}
		}

		function Ye(e) {
			if (v(e, "script")) {
				Ke(e);
			}
			B(S(e, "script"), (e) => {
				Ke(e);
			});
		}
		function Qe() {
			return document.querySelector("[hx-boost], [data-hx-boost]");
		}
		function et(e) {
			let t;
			let r;
			if (e.querySelectorAll) {
				t = Qe() ? ", a, form" : "";
				r = e.querySelectorAll(
					`${n + t}, [hx-sse], [data-hx-sse], [hx-ws], [data-hx-ws]`,
				);
				return r;
			}
			return [];
		}
		function tt(r) {
			let t;
			const e = (e) => {
				if (v(e.target, "button, input[type='submit']")) {
					t = j(r);
					t.lastButtonClicked = e.target;
				}
			};
			r.addEventListener("click", e);
			r.addEventListener("focusin", e);
			r.addEventListener("focusout", (e) => {
				t = j(r);
				t.lastButtonClicked = null;
			});
		}
		function rt(e) {
			if (e.closest?.(D.config.disableSelector)) {
				return;
			}
			const t = j(e);
			let r;
			let n;
			let i;
			let o;
			if (!t.initialized) {
				t.initialized = true;
				ft(e, "htmx:beforeProcessNode");
				if (e.value) {
					t.lastValue = e.value;
				}
				r = qe(e);
				n = Ge(e, t, r);
				if (!n && P(e, "hx-boost") === "true") {
					Te(e, t, r);
				}
				if (e.tagName === "FORM") {
					tt(e);
				}
				i = F(e, "hx-sse");
				if (i) {
					ze(e, t, i);
				}
				o = F(e, "hx-ws");
				if (o) {
					Xe(e, t, o);
				}
				ft(e, "htmx:afterProcessNode");
			}
		}
		function nt(element) {
			const modifiedElement = H(element);
			rt(modifiedElement);
			B(et(modifiedElement), (childElement) => {
				rt(childElement);
			});
		}

		function it(e) {
			return e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
		}
		function ot(e, t) {
			let r;
			if (window.CustomEvent && typeof window.CustomEvent === "function") {
				r = new CustomEvent(e, { bubbles: true, cancelable: true, detail: t });
			} else {
				r = X().createEvent("CustomEvent");
				r.initCustomEvent(e, true, true, t);
			}
			return r;
		}
		function at(e, t, r) {
			ft(e, t, V({ error: t }, r));
		}
		function st(e) {
			return e === "htmx:afterProcessNode";
		}
		function ut(e, t) {
			B(rr(e), (e) => {
				try {
					t(e);
				} catch (e) {
					lt(e);
				}
			});
		}
		function lt(e) {
			if (console.error) {
				console.error(e);
			} else if (console.log) {
				console.log("ERROR: ", e);
			}
		}
		function ft(element, t, r) {
			const modifiedElement = H(element);
			const modifiedR = r !== null ? { ...r } : {};

			modifiedR.elt = modifiedElement;
			const n = ot(t, modifiedR);

			if (D.logger && !st(t)) {
				D.logger(modifiedElement, t, modifiedR);
			}

			if (modifiedR.error) {
				lt(modifiedR.error);
				ft(modifiedElement, "htmx:error", { errorInfo: modifiedR });
			}

			let i = modifiedElement.dispatchEvent(n);
			const o = it(t);
			let a;

			if (i && o !== t) {
				a = ot(o, n.detail);
				i = i && modifiedElement.dispatchEvent(a);
			}

			ut(modifiedElement, (handler) => {
				i = i && handler.onEvent(t, n) !== false;
			});

			return i;
		}

		let ct = null;
		function ht() {
			const e = X().querySelector("[hx-history-elt],[data-hx-history-elt]");
			return e || X().body;
		}
		function dt(e, t, r, n) {
			let o;
			const i = x(localStorage.getItem("htmx-history-cache")) || [];
			for (o = 0; o < i.length; o++) {
				if (i[o].url === e) {
					i.splice(o, 1);
					break;
				}
			}
			i.push({ url: e, content: t, title: r, scroll: n });
			while (i.length > D.config.historyCacheSize) {
				i.shift();
			}
			while (i.length > 0) {
				try {
					localStorage.setItem("htmx-history-cache", JSON.stringify(i));
					break;
				} catch (e) {
					at(X().body, "htmx:historyCacheError", { cause: e, cache: i });
					i.shift();
				}
			}
		}
		function vt(e) {
			let r;
			const t = x(localStorage.getItem("htmx-history-cache")) || [];
			for (r = 0; r < t.length; r++) {
				if (t[r].url === e) {
					return t[r];
				}
			}
			return null;
		}
		function gt(e) {
			const t = D.config.requestClass;
			const r = e.cloneNode(true);
			B(S(r, `.${t}`), (e) => {
				q(e, t);
			});
			return r.innerHTML;
		}
		function pt() {
			const e = ht();
			const t = ct || location.pathname + location.search;
			ft(X().body, "htmx:beforeHistorySave", { path: t, historyElt: e });
			if (D.config.historyEnabled)
				history.replaceState({ htmx: true }, X().title, window.location.href);
			dt(t, gt(e), X().title, window.scrollY);
		}
		function mt(e) {
			if (D.config.historyEnabled) history.pushState({ htmx: true }, "", e);
			ct = e;
		}
		function yt(e) {
			B(e, (e) => {
				e.call();
			});
		}
		function xt(n) {
			let e = new XMLHttpRequest();
			const i = { path: n, xhr: e };
			let t;
			let r;
			ft(X().body, "htmx:historyCacheMiss", i);
			e.open("GET", n, true);
			e.setRequestHeader("HX-History-Restore-Request", "true");
			e.onload = function () {
				if (this.status >= 200 && this.status < 400) {
					ft(X().body, "htmx:historyCacheMissLoad", i);
					e = u(this.response);
					e = e.querySelector("[hx-history-elt],[data-hx-history-elt]") || e;
					t = ht();
					r = Xt(t);
					se(t, e, r);
					yt(r.tasks);
					ct = n;
					ft(X().body, "htmx:historyRestore", { path: n });
				} else {
					at(X().body, "htmx:historyCacheMissLoadError", i);
				}
			};
			e.send();
		}
		function bt(e) {
			pt();
			const path = e || location.pathname + location.search;
			const t = vt(path);
			let r;
			let n;
			let i;
			if (t) {
				r = u(t.content);
				n = ht();
				i = Xt(n);
				se(n, r, i);
				yt(i.tasks);
				document.title = t.title;
				window.scrollTo(0, t.scroll);
				ct = path;
				ft(X().body, "htmx:historyRestore", { path: path });
			} else {
				if (D.config.refreshOnHistoryMiss) {
					window.location.reload(true);
				} else {
					xt(path);
				}
			}
		}

		function wt(e) {
			const t = P(e, "hx-push-url");
			return (t && t !== "false") || (j(e).boosted && j(e).pushURL);
		}
		function St(e) {
			const t = P(e, "hx-push-url");
			return t === "true" || t === "false" ? null : t;
		}
		function Et(e) {
			const t = P(e, "hx-indicator");
			let r;
			if (t) {
				r = T(e, t);
			} else {
				r = [e];
			}
			B(r, (e) => {
				e.classList.add.call(e.classList, D.config.requestClass);
			});
			return r;
		}
		function Ct(e) {
			B(e, (e) => {
				e.classList.remove.call(e.classList, D.config.requestClass);
			});
		}
		function qt(e, t) {
			let r;
			let n;
			for (r = 0; r < e.length; r++) {
				n = e[r];
				if (n.isSameNode(t)) {
					return true;
				}
			}
			return false;
		}
		function Rt(e) {
			if (e.name === "" || e.name === null || e.disabled) {
				return false;
			}
			if (
				e.type === "button" ||
				e.type === "submit" ||
				e.tagName === "image" ||
				e.tagName === "reset" ||
				e.tagName === "file"
			) {
				return false;
			}
			if (e.type === "checkbox" || e.type === "radio") {
				return e.checked;
			}
			return true;
		}
		function Ot(t, r, n, e, i) {
			let o;
			let a;
			let s;
			let u;
			if (e === null || qt(t, e)) {
				return;
			}
			t.push(e);
			if (Rt(e)) {
				o = c(e, "name");
				a = e.value;
				if (e.multiple) {
					a = p(e.querySelectorAll("option:checked")).map((e) => e.value);
				}
				if (e.files) {
					a = p(e.files);
				}
				if (o != null && a != null) {
					s = r[o];
					if (s) {
						if (Array.isArray(s)) {
							if (Array.isArray(a)) {
								r[o] = s.concat(a);
							} else {
								s.push(a);
							}
						} else {
							if (Array.isArray(a)) {
								r[o] = [s].concat(a);
							} else {
								r[o] = [s, a];
							}
						}
					} else {
						r[o] = a;
					}
				}
				if (i) {
					Lt(e, n);
				}
			}
			if (v(e, "form")) {
				u = e.elements;
				B(u, (e) => {
					Ot(t, r, n, e, i);
				});
			}
		}
		function Lt(e, t) {
			if (e.willValidate) {
				ft(e, "htmx:validation:validate");
				if (!e.checkValidity()) {
					t.push({
						elt: e,
						message: e.validationMessage,
						validity: e.validity,
					});
					ft(e, "htmx:validation:failed", {
						message: e.validationMessage,
						validity: e.validity,
					});
				}
			}
		}
		function Tt(e, t) {
			const r = [];
			let n = {};
			const i = {};
			const o = [];
			const a = v(e, "form") && e.noValidate !== true;
			if (t !== "get") {
				Ot(r, i, o, L(e, "form"), a);
			}
			Ot(r, n, o, e, a);
			const s = j(e);
			let u;
			let f;
			if (s.lastButtonClicked) {
				u = c(s.lastButtonClicked, "name");
				if (u) {
					n[u] = s.lastButtonClicked.value;
				}
			}
			const l = P(e, "hx-include");
			if (l) {
				f = T(e, l);
				B(f, (e) => {
					Ot(r, n, o, e, a);
					if (!v(e, "form")) {
						B(e.querySelectorAll(Ce), (e) => {
							Ot(r, n, o, e, a);
						});
					}
				});
			}
			n = V(n, i);
			return { errors: o, values: n };
		}
		function At(e, t, r) {
			let queryString = e;

			if (queryString !== "") {
				queryString += "&";
			}
			queryString += `${encodeURIComponent(t)}=${encodeURIComponent(r)}`;

			return queryString;
		}

		function Ht(e) {
			let t = "";
			let n;
			for (const r in e) {
				if (e.hasOwn(r)) {
					n = e[r];
					if (Array.isArray(n)) {
						B(n, (e) => {
							t = At(t, r, e);
						});
					}
					t = At(t, r, n);
				}
			}
			return t;
		}
		function kt(e) {
			const t = new FormData();
			let r;
			let n;
			for (r in e) {
				if (e.hasOwn(r)) {
					n = e[r];
					if (Array.isArray(n)) {
						B(n, (e) => {
							t.append(r, e);
						});
					}
					t.append(r, n);
				}
			}
			return t;
		}
		function Nt(e, t, r) {
			const n = {
				"HX-Request": "true",
				"HX-Trigger": c(e, "id"),
				"HX-Trigger-Name": c(e, "name"),
				"HX-Target": F(t, "id"),
				"HX-Current-URL": X().location.href,
			};
			Ut(e, "hx-headers", false, n);
			if (r !== undefined) {
				n["HX-Prompt"] = r;
			}
			return n;
		}
		function It(t, e) {
			const r = P(e, "hx-params");
			let n;

			if (r) {
				if (r === "none") {
					return {};
				}
				if (r === "*") {
					return t;
				}
				if (r.indexOf("not ") === 0) {
					const excludeParams = r
						.substr(4)
						.split(",")
						.map((param) => param.trim());
					for (const param of excludeParams) {
						delete t[param];
					}
					return t;
				}
				n = {};
				const includeParams = r.split(",").map((param) => param.trim());
				for (const param of includeParams) {
					n[param] = t[param];
				}
				return n;
			}

			return t;
		}

		function Mt(e) {
			return c(e, "href") && c(e, "href").indexOf("#") >= 0;
		}
		function Dt(e) {
			const t = P(e, "hx-swap");
			const r = {
				swapStyle: j(e).boosted ? "innerHTML" : D.config.defaultSwapStyle,
				swapDelay: D.config.defaultSwapDelay,
				settleDelay: D.config.defaultSettleDelay,
			};
			let n;
			let i;
			let o;
			let a;
			let s;
			let u;
			let l;
			let f;
			let c;
			if (j(e).boosted && !Mt(e)) {
				r.show = "top";
			}
			if (t) {
				n = y(t);
				if (n.length > 0) {
					r.swapStyle = n[0];
					for (i = 1; i < n.length; i++) {
						o = n[i];
						if (o.indexOf("swap:") === 0) {
							r.swapDelay = h(o.substr(5));
						}
						if (o.indexOf("settle:") === 0) {
							r.settleDelay = h(o.substr(7));
						}
						if (o.indexOf("scroll:") === 0) {
							a = o.substr(7);
							s = a.split(":");
							u = s.pop();
							l = s.length > 0 ? s.join(":") : null;
							r.scroll = u;
							r.scrollTarget = l;
						}
						if (o.indexOf("show:") === 0) {
							f = o.substr(5);
							s = f.split(":");
							c = s.pop();
							l = s.length > 0 ? s.join(":") : null;
							r.show = c;
							r.showTarget = l;
						}
					}
				}
			}
			return r;
		}
		function Ft(t, r, n) {
			let i = null;
			ut(r, (e) => {
				if (i === null) {
					i = e.encodeParameters(t, n, r);
				}
			});
			if (i != null) {
				return i;
			}
			if (P(r, "hx-encoding") === "multipart/form-data") {
				return kt(n);
			}
			return Ht(n);
		}
		function Xt(e) {
			return { tasks: [], elts: [e] };
		}
		function Pt(e, t) {
			const r = e[0];
			const n = e[e.length - 1];
			let i;
			let o;
			if (t.scroll) {
				i = null;
				if (t.scrollTarget) {
					i = A(r, t.scrollTarget);
				}
				if (t.scroll === "top" && (r || i)) {
					i = i || r;
					i.scrollTop = 0;
				}
				if (t.scroll === "bottom" && (n || i)) {
					i = i || n;
					i.scrollTop = i.scrollHeight;
				}
			}
			if (t.show) {
				i = null;
				if (t.showTarget) {
					o = t.showTarget;
					if (t.showTarget === "window") {
						o = "body";
					}
					i = A(r, o);
				}
				if (t.show === "top" && (r || i)) {
					i = i || r;
					i.scrollIntoView({
						block: "start",
						behavior: D.config.scrollBehavior,
					});
				}
				if (t.show === "bottom" && (n || i)) {
					i = i || n;
					i.scrollIntoView({ block: "end", behavior: D.config.scrollBehavior });
				}
			}
		}
		function Ut(e, t, r, n) {
			const result = n !== null ? { ...n } : {};

			if (e === null) {
				return result;
			}

			const i = F(e, t);
			let o;
			let a;
			let s;
			let u;

			if (i) {
				o = i.trim();
				a = r;
				if (o.indexOf("javascript:") === 0) {
					o = o.substr(11);
					a = true;
				} else if (o.indexOf("js:") === 0) {
					o = o.substr(3);
					a = true;
				}
				if (o.indexOf("{") !== 0) {
					o = `{${o}}`;
				}
				if (a) {
					s = jt(e, () => Function(`return (${o})`)(), {});
				} else {
					s = x(o);
				}
				for (u in s) {
					if (s.hasOwn(u)) {
						if (result[u] === null) {
							result[u] = s[u];
						}
					}
				}
			}

			return Ut(l(e), t, r, result);
		}

		function jt(e, t, r) {
			if (D.config.allowEval) {
				return t();
			}
			at(e, "htmx:evalDisallowedError");
			return r;
		}
		function Bt(e, t) {
			return Ut(e, "hx-vars", true, t);
		}
		function zt(e, t) {
			return Ut(e, "hx-vals", false, t);
		}
		function Vt(e) {
			return V(Bt(e), zt(e));
		}
		function _t(t, r, n) {
			if (n !== null) {
				try {
					t.setRequestHeader(r, n);
				} catch (e) {
					t.setRequestHeader(r, encodeURIComponent(n));
					t.setRequestHeader(`${r}-URI-AutoEncoded`, "true");
				}
			}
		}
		function Wt(t) {
			let e;
			if (t.responseURL && typeof URL !== "undefined") {
				try {
					e = new URL(t.responseURL);
					return e.pathname + e.search;
				} catch (e) {
					at(X().body, "htmx:badResponseUrl", { url: t.responseURL });
				}
			}
		}
		function $t(e, t) {
			return e.getAllResponseHeaders().match(t);
		}
		function Jt(e, t, r) {
			if (r) {
				if (r instanceof Element || a(r, "String")) {
					return Gt(e, t, null, null, { targetOverride: H(r) });
				}
				return Gt(e, t, H(r.source), r.event, {
					handler: r.handler,
					headers: r.headers,
					values: r.values,
					targetOverride: H(r.target),
				});
			}
			return Gt(e, t);
		}
		function Zt(element) {
			const elements = [];
			let currentElement = element;

			while (currentElement) {
				elements.push(currentElement);
				currentElement = currentElement.parentElement;
			}

			return elements;
		}

		function Gt(e, t, n, r, i) {
			let o = null;
			let a = null;
			let s;
			let c;
			let h;
			const modifiedI = i != null ? { ...i } : {};
			let path = t;
			let bodyElement = n; // Nouvelle variable pour manipuler `n`
			const event = r;

			if (typeof Promise !== "undefined") {
				s = new Promise((resolve, reject) => {
					o = resolve;
					a = reject;
				});
			}
			if (bodyElement === null) {
				bodyElement = X().body;
			}
			const u = modifiedI.handler || Kt;
			if (!z(bodyElement)) {
				return;
			}
			const l = modifiedI.targetOverride || _(bodyElement);
			if (l === null) {
				at(bodyElement, "htmx:targetError", {
					target: F(bodyElement, "hx-target"),
				});
				return;
			}
			const f = j(bodyElement);
			if (f.requestInFlight) {
				c = "last";
				if (event) {
					h = j(event);
					if (h?.triggerSpec?.queue) {
						c = h.triggerSpec.queue;
					}
				}
				if (f.queuedRequests === null) {
					f.queuedRequests = [];
				}
				if (c === "first" && f.queuedRequests.length === 0) {
					f.queuedRequests.push(() => {
						Gt(e, path, bodyElement, event);
					});
				} else if (c === "all") {
					f.queuedRequests.push(() => {
						Gt(e, path, bodyElement, event);
					});
				} else if (c === "last") {
					f.queuedRequests = [];
					f.queuedRequests.push(() => {
						Gt(e, path, bodyElement, event);
					});
				}
				return;
			}
			f.requestInFlight = true;
			let requestFunc;
			const d = () => {
				f.requestInFlight = false;
				if (f.queuedRequests != null && f.queuedRequests.length > 0) {
					requestFunc = f.queuedRequests.shift();
					requestFunc();
				}
			};
			const promptMessage = P(bodyElement, "hx-prompt");
			let promptValue;
			if (promptMessage) {
				promptValue = prompt(promptMessage);
				if (
					promptValue === null ||
					!ft(bodyElement, "htmx:prompt", { prompt: promptValue, target: l })
				) {
					U(o);
					d();
					return s;
				}
			}
			const confirmMessage = P(bodyElement, "hx-confirm");
			if (confirmMessage) {
				if (!confirm(confirmMessage)) {
					U(o);
					d();
					return s;
				}
			}
			const xhr = new XMLHttpRequest();
			let headers = Nt(bodyElement, l, promptValue);
			if (modifiedI.headers) {
				headers = V(headers, modifiedI.headers);
			}
			const validationResult = Tt(bodyElement, path);
			let validationErrors = validationResult.errors;
			let validationValues = validationResult.values;
			if (modifiedI.values) {
				validationValues = V(validationValues, modifiedI.values);
			}
			const swapInfo = Vt(bodyElement);
			const mergedValues = V(validationValues, swapInfo);
			let requestParams = It(mergedValues, bodyElement);
			if (path !== "get" && P(bodyElement, "hx-encoding") === null) {
				headers["Content-Type"] =
					"application/x-www-form-urlencoded; charset=UTF-8";
			}
			if (!path) {
				path = X().location.href;
			}
			const requestConfig = Ut(bodyElement, "hx-request");
			const R = {
				parameters: requestParams,
				unfilteredParameters: mergedValues,
				headers: headers,
				target: l,
				verb: path,
				errors: validationErrors,
				withCredentials:
					modifiedI.credentials ||
					requestConfig.credentials ||
					D.config.withCredentials,
				timeout: modifiedI.timeout || requestConfig.timeout || D.config.timeout,
				path: path,
				triggeringEvent: event,
			};
			if (!ft(bodyElement, "htmx:configRequest", R)) {
				U(o);
				d();
				return s;
			}
			path = R.path;
			const verb = R.verb;
			headers = R.headers;
			requestParams = R.parameters;
			validationErrors = R.errors;
			if (validationErrors && validationErrors.length > 0) {
				ft(bodyElement, "htmx:validation:halted", R);
				U(o);
				d();
				return s;
			}
			const pathParts = path.split("#");
			const mainPath = pathParts[0];
			const anchor = pathParts[1];
			let finalPath = mainPath;
			const includeParams = Object.keys(requestParams).length !== 0;
			if (verb === "get") {
				if (includeParams) {
					if (finalPath.indexOf("?") < 0) {
						finalPath += "?";
					} else {
						finalPath += "&";
					}
					finalPath += Ht(requestParams);
					if (anchor) {
						finalPath += `#${anchor}`;
					}
				}
				xhr.open("GET", finalPath, true);
			} else {
				xhr.open(verb.toUpperCase(), path, true);
			}
			xhr.overrideMimeType("text/html");
			xhr.withCredentials = R.withCredentials;
			xhr.timeout = R.timeout;
			let headerKey;
			let headerValue;
			if (!requestConfig.noHeaders) {
				for (headerKey in headers) {
					if (headers.hasOwn(headerKey)) {
						headerValue = headers[headerKey];
						_t(xhr, headerKey, headerValue);
					}
				}
			}
			const requestInfo = {
				xhr: xhr,
				target: l,
				requestConfig: R,
				pathInfo: { path: path, finalPath: finalPath, anchor: anchor },
			};
			let parentElements;
			let currentElement;
			xhr.onload = () => {
				try {
					parentElements = Zt(bodyElement);
					u(bodyElement, requestInfo);
					Ct(M);
					ft(bodyElement, "htmx:afterRequest", requestInfo);
					ft(bodyElement, "htmx:afterOnLoad", requestInfo);
					if (!z(bodyElement)) {
						currentElement = null;
						while (parentElements.length > 0 && currentElement === null) {
							currentElement = parentElements.shift();
							if (z(currentElement)) {
								ft(currentElement, "htmx:afterRequest", requestInfo);
								ft(currentElement, "htmx:afterOnLoad", requestInfo);
							}
						}
					}
					U(o);
					d();
				} catch (error) {
					at(bodyElement, "htmx:onLoadError", V({ error: error }, requestInfo));
					throw error;
				}
			};
			xhr.onerror = () => {
				Ct(M);
				at(bodyElement, "htmx:afterRequest", requestInfo);
				at(bodyElement, "htmx:sendError", requestInfo);
				U(a);
				d();
			};
			xhr.onabort = () => {
				Ct(M);
				at(bodyElement, "htmx:afterRequest", requestInfo);
				at(bodyElement, "htmx:sendAbort", requestInfo);
				U(a);
				d();
			};
			xhr.ontimeout = () => {
				Ct(M);
				at(bodyElement, "htmx:afterRequest", requestInfo);
				at(bodyElement, "htmx:timeout", requestInfo);
				U(a);
				d();
			};
			if (!ft(bodyElement, "htmx:beforeRequest", requestInfo)) {
				U(o);
				d();
				return s;
			}
			const M = Et(bodyElement);
			B(["loadstart", "loadend", "progress", "abort"], (eventType) => {
				B([xhr, xhr.upload], (xhrPart) => {
					xhrPart.addEventListener(eventType, (event) => {
						ft(bodyElement, `htmx:xhr:${eventType}`, {
							lengthComputable: event.lengthComputable,
							loaded: event.loaded,
							total: event.total,
						});
					});
				});
			});
			ft(bodyElement, "htmx:beforeSend", requestInfo);
			xhr.send(verb === "get" ? null : Ft(xhr, bodyElement, requestParams));
			return s;
		}

		function Kt(a, s) {
			const u = s.xhr;
			const l = s.target;
			if (!ft(a, "htmx:beforeOnLoad", s)) return;
			if ($t(u, /HX-Trigger:/i)) {
				de(u, "HX-Trigger", a);
			}
			let f;
			if ($t(u, /HX-Push:/i)) {
				f = u.getResponseHeader("HX-Push");
			}
			if ($t(u, /HX-Redirect:/i)) {
				window.location.href = u.getResponseHeader("HX-Redirect");
				return;
			}
			if ($t(u, /HX-Refresh:/i)) {
				if ("true" === u.getResponseHeader("HX-Refresh")) {
					location.reload();
					return;
				}
			}
			const c = wt(a) || f;
			let h;
			let d;
			let o;
			let e;
			let t;
			let r;
			let n;
			let i;
			if (u.status >= 200 && u.status < 400) {
				if (u.status === 286) {
					Re(a);
				}
				if (u.status !== 204) {
					if (!ft(l, "htmx:beforeSwap", s)) return;
					h = u.response;
					ut(a, (e) => {
						h = e.transformResponse(h, u, a);
					});
					if (c) {
						pt();
					}
					d = Dt(a);
					l.classList.add(D.config.swappingClass);
					e = () => {
						try {
							e = document.activeElement;
							t = {};
							try {
								t = {
									elt: e,
									start: e ? e.selectionStart : null,
									end: e ? e.selectionEnd : null,
								};
							} catch (e) {}
							r = Xt(l);
							he(d.swapStyle, l, a, h, r);
							if (t.elt && !z(t.elt) && t.elt.id) {
								n = document.getElementById(t.elt.id);
								if (n) {
									if (t.start && n.setSelectionRange) {
										n.setSelectionRange(t.start, t.end);
									}
									n.focus();
								}
							}
							l.classList.remove(D.config.swappingClass);
							B(r.elts, (e) => {
								if (e.classList) {
									e.classList.add(D.config.settlingClass);
								}
								ft(e, "htmx:afterSwap", s);
							});
							if (s.pathInfo.anchor) {
								location.hash = s.pathInfo.anchor;
							}
							if ($t(u, /HX-Trigger-After-Swap:/i)) {
								i = a;
								if (!z(a)) {
									i = X().body;
								}
								de(u, "HX-Trigger-After-Swap", i);
							}
							o = () => {
								B(r.tasks, (e) => {
									e.call();
								});
								B(r.elts, (e) => {
									if (e.classList) {
										e.classList.remove(D.config.settlingClass);
									}
									ft(e, "htmx:afterSettle", s);
								});
								if (c) {
									e =
										f ||
										St(a) ||
										Wt(u) ||
										s.pathInfo.finalPath ||
										s.pathInfo.path;
									mt(e);
									ft(X().body, "htmx:pushedIntoHistory", { path: e });
								}
								Pt(r.elts, d);
								if ($t(u, /HX-Trigger-After-Settle:/i)) {
									t = a;
									if (!z(a)) {
										t = X().body;
									}
									de(u, "HX-Trigger-After-Settle", t);
								}
							};
							if (d.settleDelay > 0) {
								setTimeout(o, d.settleDelay);
							} else {
								o();
							}
						} catch (e) {
							at(a, "htmx:swapError", s);
							throw e;
						}
					};
					if (d.swapDelay > 0) {
						setTimeout(e, d.swapDelay);
					} else {
						e();
					}
				}
			} else {
				at(
					a,
					"htmx:responseError",
					V(
						{
							error: `Response Status Error Code ${u.status} from ${s.pathInfo.path}`,
						},
						s,
					),
				);
			}
		}
		const Yt = {};
		function Qt() {
			return {
				onEvent: (e, t) => true,
				transformResponse: (e, t, r) => e,
				isInlineSwap: (e) => false,
				handleSwap: (e, t, r, n) => false,
				encodeParameters: (e, t, r) => null,
			};
		}
		function er(e, t) {
			Yt[e] = V(Qt(), t);
		}
		function tr(e) {
			delete Yt[e];
		}
		function rr(element, extensions, ignored) {
			const currentElement = element;
			const processedExtensions =
				extensions !== undefined ? [...extensions] : [];
			const ignoredExtensions = ignored !== undefined ? [...ignored] : [];

			if (currentElement === undefined) {
				return processedExtensions;
			}

			const extAttr = F(currentElement, "hx-ext");
			if (extAttr) {
				const extList = extAttr.split(",").map((ext) => ext.replace(/ /g, ""));
				for (const ext of extList) {
					if (ext.slice(0, 7) === "ignore:") {
						ignoredExtensions.push(ext.slice(7));
					} else if (ignoredExtensions.indexOf(ext) < 0) {
						const extFunction = Yt[ext];
						if (extFunction && processedExtensions.indexOf(extFunction) < 0) {
							processedExtensions.push(extFunction);
						}
					}
				}
			}

			return rr(l(currentElement), processedExtensions, ignoredExtensions);
		}

		function nr(e) {
			if (X().readyState !== "loading") {
				e();
			} else {
				X().addEventListener("DOMContentLoaded", e);
			}
		}
		function ir() {
			if (D.config.includeIndicatorStyles !== false) {
				X().head.insertAdjacentHTML(
					"beforeend",
					`<style>                      .${D.config.indicatorClass}{opacity:0;transition: opacity 200ms ease-in;}                      .${D.config.requestClass} .${D.config.indicatorClass}{opacity:1}                      .${D.config.requestClass}.${D.config.indicatorClass}{opacity:1}                    </style>`,
				);
			}
		}
		function or() {
			const e = X().querySelector('meta[name="htmx-config"]');
			if (e) {
				return x(e.content);
			}
			return null;
		}
		function ar() {
			const e = or();
			if (e) {
				D.config = V(D.config, e);
			}
		}
		nr(() => {
			ar();
			ir();
			const e = X().body;
			nt(e);
			window.onpopstate = (e) => {
				if (e.state?.htmx) {
					bt();
				}
			};
			setTimeout(() => {
				ft(e, "htmx:load", {});
			}, 0);
		});
		return D;
	})(),
);
